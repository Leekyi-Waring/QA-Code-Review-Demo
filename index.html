<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MXDR365 KQL Query Analyzer - Enterprise Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Segoe+UI:wght@300;400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --mxdr-primary: #0078d4;
            --mxdr-secondary: #106ebe;
            --mxdr-accent: #40e0d0;
            --mxdr-success: #107c10;
            --mxdr-warning: #ff8c00;
            --mxdr-error: #d13438;
            --mxdr-critical: #a4262c;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #f3f2f1;
            --text-primary: #323130;
            --text-secondary: #605e5c;
            --border-light: #edebe9;
            --border-medium: #d2d0ce;
            --card-shadow: 0 2px 4px rgba(0,0,0,0.1);
            --card-shadow-hover: 0 4px 8px rgba(0,0,0,0.15);
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, var(--mxdr-primary) 0%, var(--mxdr-secondary) 100%);
            color: white;
            padding: 32px 0;
            text-align: center;
            box-shadow: var(--card-shadow);
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .header .subtitle {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .header .version {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 4px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 500px;
            gap: 24px;
        }

        .main-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 24px;
            box-shadow: var(--card-shadow);
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .query-editor {
            width: 100%;
            height: 350px;
            background: #f8f8f8;
            border: 1px solid var(--border-medium);
            border-radius: 4px;
            padding: 16px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            color: var(--text-primary);
            resize: vertical;
            outline: none;
            transition: border-color 0.2s ease;
            line-height: 1.5;
        }

        .query-editor:focus {
            border-color: var(--mxdr-primary);
            box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
        }

        .controls {
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .control-select {
            padding: 8px 12px;
            border: 1px solid var(--border-medium);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: border-color 0.2s ease;
        }

        .control-select:focus {
            border-color: var(--mxdr-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
        }

        .analyze-button {
            width: 100%;
            padding: 12px 24px;
            background: var(--mxdr-primary);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 16px;
        }

        .analyze-button:hover {
            background: var(--mxdr-secondary);
        }

        .results-panel {
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            position: sticky;
            top: 20px;
        }

        .score-display {
            text-align: center;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-light);
        }

        .score-number {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .score-details {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .score-grade {
            font-size: 1.1rem;
            font-weight: 600;
            padding: 6px 16px;
            border-radius: 4px;
            display: inline-block;
            margin-top: 8px;
        }

        .grade-excellent { background: var(--mxdr-success); color: white; }
        .grade-good { background: var(--mxdr-primary); color: white; }
        .grade-fair { background: var(--mxdr-warning); color: white; }
        .grade-poor { background: var(--mxdr-error); color: white; }
        .grade-fail { background: var(--mxdr-critical); color: white; }

        .analysis-section {
            margin-bottom: 20px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            overflow: hidden;
        }

        .analysis-header {
            background: var(--bg-secondary);
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .analysis-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .analysis-score {
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .score-excellent { background: var(--mxdr-success); color: white; }
        .score-good { background: var(--mxdr-primary); color: white; }
        .score-fair { background: var(--mxdr-warning); color: white; }
        .score-poor { background: var(--mxdr-error); color: white; }

        .analysis-content {
            padding: 16px;
        }

        .issue-item {
            padding: 14px;
            border-radius: 4px;
            border-left: 3px solid;
            background: var(--bg-secondary);
            margin-bottom: 12px;
        }

        .issue-critical { border-left-color: var(--mxdr-critical); }
        .issue-major { border-left-color: var(--mxdr-error); }
        .issue-minor { border-left-color: var(--mxdr-warning); }
        .issue-suggestion { border-left-color: var(--mxdr-primary); }
        .issue-good { border-left-color: var(--mxdr-success); }

        .issue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .issue-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .issue-severity {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .severity-critical { background: var(--mxdr-critical); color: white; }
        .severity-major { background: var(--mxdr-error); color: white; }
        .severity-minor { background: var(--mxdr-warning); color: white; }
        .severity-suggestion { background: var(--mxdr-primary); color: white; }
        .severity-good { background: var(--mxdr-success); color: white; }

        .issue-description {
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .issue-fix {
            background: rgba(0, 120, 212, 0.08);
            border: 1px solid rgba(0, 120, 212, 0.2);
            border-radius: 4px;
            padding: 10px;
            color: var(--text-primary);
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .ai-recommendations {
            background: linear-gradient(135deg, rgba(64, 224, 208, 0.1), rgba(0, 120, 212, 0.1));
            border: 1px solid var(--mxdr-accent);
            border-radius: 6px;
            padding: 16px;
            margin-top: 16px;
        }

        .ai-title {
            font-weight: 600;
            color: var(--mxdr-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-content {
            color: var(--text-primary);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin: 16px 0;
        }

        .metric-card {
            text-align: center;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 4px;
            border: 1px solid var(--border-light);
        }

        .metric-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--mxdr-primary);
        }

        .metric-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        .ai-chat {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 380px;
            height: 450px;
            background: var(--bg-primary);
            border: 1px solid var(--border-medium);
            border-radius: 8px;
            box-shadow: var(--card-shadow-hover);
            display: none;
            flex-direction: column;
            z-index: 1000;
        }

        .ai-chat-header {
            background: var(--mxdr-primary);
            color: white;
            padding: 12px 16px;
            border-radius: 8px 8px 0 0;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .ai-chat-body {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            font-size: 0.85rem;
        }

        .ai-chat-input {
            display: flex;
            padding: 12px;
            border-top: 1px solid var(--border-light);
            background: var(--bg-secondary);
        }

        .ai-chat-input input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border-medium);
            border-radius: 4px;
            margin-right: 8px;
            font-size: 0.85rem;
            outline: none;
        }

        .ai-chat-button {
            padding: 8px 16px;
            background: var(--mxdr-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .chat-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            background: var(--mxdr-primary);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.3rem;
            box-shadow: var(--card-shadow-hover);
            transition: background-color 0.2s ease;
        }

        .chat-toggle:hover {
            background: var(--mxdr-secondary);
        }

        .chat-message {
            margin-bottom: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            line-height: 1.4;
            font-size: 0.85rem;
        }

        .chat-user {
            background: var(--mxdr-primary);
            color: white;
            margin-left: 20px;
        }

        .chat-ai {
            background: var(--bg-secondary);
            color: var(--text-primary);
            margin-right: 20px;
        }

        .welcome-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .welcome-state h3 {
            color: var(--text-primary);
            margin-bottom: 16px;
            font-size: 1.1rem;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .results-panel {
                position: static;
                max-height: none;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .ai-chat {
                width: 320px;
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔬 MXDR365 KQL Query Analyzer</h1>
        <div class="subtitle">Enterprise-Grade KQL Analysis & Optimization Platform</div>
        <div class="version">Version 2.1.0 - Enterprise Edition</div>
    </div>

    <div class="container">
        <div class="main-section">
            <div class="section-title">
                📝 KQL Query Analysis Engine
            </div>
            
            <textarea 
                id="queryEditor" 
                class="query-editor" 
                placeholder="// Enter your KQL query for comprehensive MXDR365 analysis
// Example:
SecurityEvent
| where TimeGenerated > ago(7d)
| where EventID == 4624
| where LogonType == 2
| summarize LoginCount = count() by Account, Computer
| where LoginCount > 10
| order by LoginCount desc"
            ></textarea>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">Analysis Depth</label>
                    <select id="analysisDepth" class="control-select">
                        <option value="standard">Standard Analysis</option>
                        <option value="thorough">Thorough Review</option>
                        <option value="comprehensive" selected>Comprehensive Audit</option>
                        <option value="enterprise">Enterprise Standard</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Target Environment</label>
                    <select id="targetEnvironment" class="control-select">
                        <option value="sentinel" selected>Azure Sentinel</option>
                        <option value="analytics">Log Analytics</option>
                        <option value="defender">Microsoft 365 Defender</option>
                        <option value="adx">Azure Data Explorer</option>
                        <option value="fabric">Microsoft Fabric</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Query Purpose</label>
                    <select id="queryPurpose" class="control-select">
                        <option value="hunting">Threat Hunting</option>
                        <option value="detection">Detection Rule</option>
                        <option value="analytics" selected>Security Analytics</option>
                        <option value="investigation">Incident Investigation</option>
                        <option value="reporting">Executive Reporting</option>
                        <option value="automation">SOAR Automation</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Performance Focus</label>
                    <select id="performanceFocus" class="control-select">
                        <option value="balanced" selected>Balanced</option>
                        <option value="speed">Maximum Speed</option>
                        <option value="accuracy">Maximum Accuracy</option>
                        <option value="cost">Cost Optimization</option>
                        <option value="scale">Enterprise Scale</option>
                    </select>
                </div>
            </div>

            <button id="analyzeButton" class="analyze-button">
                🎯 Analyze Query with MXDR365 AI
            </button>
        </div>

        <div class="results-panel">
            <div class="section-title">
                📊 Analysis Results
            </div>
            
            <div id="welcomeState" class="welcome-state">
                <h3>MXDR365 AI Ready</h3>
                <p>Enter your KQL query and click "Analyze" to receive comprehensive analysis with AI-powered recommendations.</p>
                <div style="margin-top: 20px; padding: 16px; background: var(--bg-secondary); border-radius: 6px; font-size: 0.85rem;">
                    <strong>Comprehensive Analysis includes:</strong><br>
                    • Query validation & structure analysis<br>
                    • Performance optimization recommendations<br>
                    • Security best practices assessment<br>
                    • AI-powered improvement suggestions<br>
                    • Enterprise compliance scoring<br>
                    • Real-time chat assistance
                </div>
            </div>
            
            <div id="resultsContent" style="display: none;"></div>
        </div>
    </div>

    <!-- AI Chat Interface -->
    <button id="chatToggle" class="chat-toggle">🤖</button>
    
    <div id="aiChat" class="ai-chat">
        <div class="ai-chat-header">
            🤖 MXDR365 AI Assistant
            <button onclick="toggleChat()" style="background:none;border:none;color:white;cursor:pointer;font-size:1.1rem;">×</button>
        </div>
        <div class="ai-chat-body" id="chatBody">
            <div class="chat-message chat-ai">
                Hello! I'm your MXDR365 AI assistant. I provide intelligent KQL guidance including:
                <br><br>
                • Query optimization strategies<br>
                • Performance troubleshooting<br>
                • Security best practices<br>
                • Syntax explanations<br>
                • Enterprise compliance tips<br>
                • Custom recommendations
            </div>
        </div>
        <div class="ai-chat-input">
            <input type="text" id="chatInput" placeholder="Ask about KQL..." onkeypress="handleChatEnter(event)">
            <button class="ai-chat-button" onclick="sendMessage()">Send</button>
        </div>
    </div>

    <script>
        class MXDR365KQLAnalyzer {
            constructor() {
                this.initializeEventListeners();
                this.initializeValidationEngine();
                this.initializeAIEngine();
            }

            initializeEventListeners() {
                document.getElementById('analyzeButton').addEventListener('click', () => this.analyzeQuery());
                document.getElementById('chatToggle').addEventListener('click', () => this.toggleChat());
            }

            initializeValidationEngine() {
                // Comprehensive Microsoft table validation
                this.validTables = new Set([
                    'SecurityEvent', 'SigninLogs', 'AuditLogs', 'DeviceEvents', 'DeviceProcessEvents',
                    'DeviceNetworkEvents', 'DeviceFileEvents', 'DeviceRegistryEvents', 'DeviceLogonEvents',
                    'IdentityInfo', 'IdentityDirectoryEvents', 'IdentityLogonEvents', 'IdentityQueryEvents',
                    'EmailEvents', 'EmailAttachmentInfo', 'EmailUrlInfo', 'EmailPostDeliveryEvents',
                    'AlertInfo', 'AlertEvidence', 'ThreatIntelligenceIndicator', 'DeviceInfo',
                    'Heartbeat', 'Usage', 'Operation', 'Perf', 'Event', 'Syslog', 'SecurityAlert',
                    'SecurityIncident', 'CommonSecurityLog', 'AADNonInteractiveUserSignInLogs',
                    'AADServicePrincipalSignInLogs', 'AADManagedIdentitySignInLogs', 'DeviceNetworkInfo',
                    'DeviceTvmSoftwareInventory', 'DeviceTvmSoftwareVulnerabilities', 'AppFileEvents',
                    'BehaviorAnalytics', 'CloudAppEvents', 'UrlClickEvents', 'OfficeActivity',
                    'PowerBIAudit', 'AzureActivity', 'AzureDiagnostics', 'WindowsEvent', 'Watchlist',
                    'InsightsMetrics', 'SecurityRecommendation', 'Update', 'UpdateSummary', 'VMConnection',
                    'W3CIISLog', 'Wire', 'WireData', 'ServiceFabricOperationalEvent', 'ServiceMapComputer_CL'
                ]);

                // Time-series tables that require datetime filtering
                this.timeSeriesIndicators = new Set([
                    'SecurityEvent', 'Event', 'Syslog', 'Perf', 'Heartbeat',
                    'AuditLogs', 'SigninLogs', 'DeviceEvents', 'WindowsEvent',
                    'DeviceProcessEvents', 'DeviceNetworkEvents', 'DeviceFileEvents',
                    'CommonSecurityLog', 'AzureActivity', 'OfficeActivity'
                ]);

                // Auto-fail patterns - immediate 0 score
                this.autoFailPatterns = {
                    syntax: [
                        /[^|]\s*\|\s*[^|].*[^|]\s*\|\s*[^|]/g, // Missing pipes
                        /['""][^'""]*$/g, // Unclosed quotes
                        /\([^)]*$/g, // Unclosed parentheses
                        /==\s*['"]\d+['"]/g // Numeric comparison with quotes
                    ],
                    performance: [
                        /^\s*\w+\s*\|\s*search\s+/g, // search as first operation
                        /\|\s*project\s+\*/g, // project * (select all)
                        /\|\s*join\s+.*\|\s*where.*TimeGenerated/g, // where after join
                        /union\s+\*/g // union all tables
                    ],
                    security: [
                        /let\s+\w+\s*=\s*['"]\$\{.*\}['"]/g, // Dynamic query construction
                        /password['"]\s*:\s*['"]\w+/g, // Hardcoded passwords
                        /secret['"]\s*:\s*['"]\w+/g, // Hardcoded secrets
                        /evaluate\s+.*query\(/g // Dynamic query execution
                    ]
                };

                // Comprehensive scoring patterns (1000 point system)
                this.scoringPatterns = {
                    syntax: {
                        maxPoints: 150,
                        rules: [
                            {
                                pattern: /\b(WHERE|PROJECT|SUMMARIZE|EXTEND|JOIN|UNION|ORDER|TOP|DISTINCT|TAKE|LIMIT)\b/g,
                                points: -10,
                                title: 'Incorrect Operator Casing',
                                description: 'KQL operators should be lowercase',
                                severity: 'minor'
                            },
                            {
                                pattern: /SELECT\s+/g,
                                points: -25,
                                title: 'SQL Syntax in KQL',
                                description: 'Using SQL SELECT instead of KQL project',
                                severity: 'major'
                            },
                            {
                                pattern: /\s+\|\s*$/g,
                                points: -15,
                                title: 'Trailing Pipe Operator',
                                description: 'Query ends with unnecessary pipe',
                                severity: 'minor'
                            },
                            {
                                pattern: /^\s*\|/g,
                                points: -15,
                                title: 'Leading Pipe Operator',
                                description: 'Query starts with pipe operator',
                                severity: 'minor'
                            }
                        ]
                    },
                    performance: {
                        maxPoints: 300,
                        rules: [
                            {
                                test: (query) => this.checkTimeFilterRequirement(query),
                                points: -100,
                                title: 'Missing Required DateTime Filter',
                                description: 'Time-series data queries must include TimeGenerated filter',
                                severity: 'critical'
                            },
                            {
                                pattern: /\|\s*where\s+.*\|\s*summarize.*\|\s*where/g,
                                points: -100,
                                title: 'Filter After Summarize Anti-Pattern',
                                description: 'Filtering after aggregation wastes resources',
                                severity: 'major'
                            },
                            {
                                pattern: /join\s+kind=fullouter/g,
                                points: -100,
                                title: 'Full Outer Join Performance Issue',
                                description: 'Full outer joins are usually incorrect and expensive',
                                severity: 'major'
                            },
                            {
                                pattern: /\|\s*extend.*\|\s*where/g,
                                points: -50,
                                title: 'Compute Before Filter Pattern',
                                description: 'Computing before filtering wastes resources',
                                severity: 'major'
                            },
                            {
                                pattern: /\|\s*order\s+by.*\|\s*take/g,
                                points: -30,
                                title: 'Sort Before Limit Anti-Pattern',
                                description: 'Use top N instead of order by + take',
                                severity: 'minor'
                            },
                            {
                                pattern: /join\s+(?!kind=)/g,
                                points: -50,
                                title: 'Missing Join Kind Specification',
                                description: 'Always specify join kind for clarity and performance',
                                severity: 'major'
                            }
                        ]
                    },
                    security: {
                        maxPoints: 200,
                        rules: [
                            {
                                pattern: /project.*(?:password|secret|token|credential|ssn|social)/gi,
                                points: -100,
                                title: 'Sensitive Data Exposure Risk',
                                description: 'Query may expose sensitive data fields',
                                severity: 'critical'
                            },
                            {
                                pattern: /search\s+['"]\*['"]/g,
                                points: -100,
                                title: 'Overly Broad Search Pattern',
                                description: 'Wildcard search patterns are security risks',
                                severity: 'major'
                            },
                            {
                                pattern: /where.*['"]\*['"]/g,
                                points: -50,
                                title: 'Wildcard in Where Clause',
                                description: 'Wildcard filtering may expose unintended data',
                                severity: 'major'
                            },
                            {
                                pattern: /ago\([3-9]\d+d\)/g,
                                points: -25,
                                title: 'Extended Time Range Access',
                                description: 'Accessing data older than 30 days without justification',
                                severity: 'minor'
                            }
                        ]
                    },
                    functionality: {
                        maxPoints: 200,
                        rules: [
                            {
                                pattern: /where.*EventID.*contains.*\d+/g,
                                points: -25,
                                title: 'Incorrect EventID Filtering',
                                description: 'EventID should use equality, not contains',
                                severity: 'minor'
                            },
                            {
                                pattern: /where.*TimeGenerated.*['""]\d{4}-\d{2}-\d{2}['"]/g,
                                points: -30,
                                title: 'String Date Comparison',
                                description: 'Use datetime() function for date comparisons',
                                severity: 'major'
                            },
                            {
                                pattern: /summarize.*count\(\)\s*by.*count\(/g,
                                points: -25,
                                title: 'Redundant Counting Logic',
                                description: 'Double counting in aggregation',
                                severity: 'minor'
                            },
                            {
                                pattern: /distinct.*\|\s*distinct/g,
                                points: -20,
                                title: 'Redundant Distinct Operations',
                                description: 'Multiple distinct operations are unnecessary',
                                severity: 'minor'
                            },
                            {
                                pattern: /==\s*['"]\d+['"]/g,
                                points: -30,
                                title: 'Type Mismatch in Comparison',
                                description: 'Comparing numbers as strings',
                                severity: 'major'
                            }
                        ]
                    },
                    readability: {
                        maxPoints: 100,
                        rules: [
                            {
                                test: (query) => this.checkCommentRatio(query),
                                points: 0, // Calculated dynamically
                                title: 'Documentation Quality',
                                description: 'Query documentation and comments',
                                severity: 'suggestion'
                            },
                            {
                                pattern: /let\s+[a-z]\s*=/g,
                                points: -10,
                                title: 'Poor Variable Naming',
                                description: 'Use descriptive variable names',
                                severity: 'minor'
                            },
                            {
                                pattern: /\|[^\s]/g,
                                points: -5,
                                title: 'Poor Formatting',
                                description: 'Add space after pipe operators',
                                severity: 'minor'
                            },
                            {
                                pattern: /.{200,}/g,
                                points: -10,
                                title: 'Line Length Violation',
                                description: 'Lines should be under 200 characters',
                                severity: 'minor'
                            }
                        ]
                    },
                    advanced: {
                        maxPoints: 50,
                        rules: [
                            {
                                pattern: /make-series|parse\s+|parse_json\(|geo_info_from_ip_address\(|materialize\(/g,
                                points: +10,
                                title: 'Advanced Feature Usage',
                                description: 'Using advanced KQL features effectively',
                                severity: 'good'
                            },
                            {
                                pattern: /hint\.broadcast|hint\.shufflekey|partition\s+by/g,
                                points: +10,
                                title: 'Performance Optimization Features',
                                description: 'Using performance optimization hints',
                                severity: 'good'
                            },
                            {
                                pattern: /lookup\s+kind=|has\s+|has_any\(|in~\s*\(/g,
                                points: +5,
                                title: 'Efficient Operator Usage',
                                description: 'Using efficient operators for better performance',
                                severity: 'good'
                            }
                        ]
                    }
                };

                // PII fields for security analysis
                this.piiFields = new Set([
                    'email', 'EmailAddress', 'UserPrincipalName',
                    'phone', 'PhoneNumber', 'AccountName', 'UserName',
                    'Account', 'User', 'Identity'
                ]);
            }

            initializeAIEngine() {
                this.aiPersonality = {
                    expertise: 'MXDR365 KQL Optimization Specialist',
                    tone: 'Professional, Helpful, Technical',
                    focus: 'Enterprise Security Analytics'
                };
            }

            validateTableNames(query) {
                const tablePattern = /^(\w+)(?:\s*\||\s*$)/gm;
                const matches = [...query.matchAll(tablePattern)];
                const usedTables = matches.map(m => m[1]).filter(t => 
                    !['let', 'print', 'range', 'datatable'].includes(t.toLowerCase())
                );

                const invalidTables = usedTables.filter(table => !this.validTables.has(table));
                return invalidTables.length > 0 ? `Invalid tables detected: ${invalidTables.join(', ')}. These tables do not exist in Microsoft security environments.` : null;
            }

            validateBasicStructure(query) {
                const trimmed = query.trim();
                
                if (trimmed.length < 15) {
                    return 'Query is too short to be meaningful for analysis';
                }

                if (!/^(let\s+\w+|[a-zA-Z]\w*)/.test(trimmed)) {
                    return 'Query must start with a valid table name or let statement';
                }

                const openParens = (trimmed.match(/\(/g) || []).length;
                const closeParens = (trimmed.match(/\)/g) || []).length;
                if (openParens !== closeParens) {
                    return 'Unmatched parentheses detected in query structure';
                }

                return null;
            }

            validateOperators(query) {
                const operatorPattern = /\|\s*([a-zA-Z-]+)/g;
                const matches = [...query.matchAll(operatorPattern)];
                const usedOperators = matches.map(m => m[1].toLowerCase());

                const invalidOperators = usedOperators.filter(op => !this.validOperators.has(op));
                return invalidOperators.length > 0 ? `Invalid KQL operators detected: ${invalidOperators.join(', ')}. These are not valid KQL operators.` : null;
            }

            validateMeaningfulness(query) {
                const trimmed = query.trim().toLowerCase();
                
                const nonsensePatterns = [
                    /^test|demo|example|fake|dummy|placeholder/,
                    /abcd|1234|qwerty|asdf|zxcv|lorem|ipsum/,
                    /^[a-z]+\s*$/
                ];

                for (const pattern of nonsensePatterns) {
                    if (pattern.test(trimmed)) {
                        return 'Query appears to contain test/placeholder content without analytical value';
                    }
                }

                const hasAnalysis = /where|summarize|project|extend|join|order|top|count|distinct/.test(trimmed);
                if (!hasAnalysis) {
                    return 'Query lacks analytical operations (filtering, summarization, aggregation, etc.)';
                }

                return null;
            }

            analyzeQuery() {
                const query = document.getElementById('queryEditor').value.trim();
                
                if (!query) {
                    this.showAlert('Please enter a KQL query to analyze.');
                    return;
                }

                const analysis = this.performComprehensiveAnalysis(query);
                this.displayResults(analysis);
            }

            performComprehensiveAnalysis(query) {
                // Initialize 1000-point scoring system
                const results = {
                    totalScore: 1000,
                    maxScore: 1000,
                    categoryScores: {
                        syntax: { score: 150, maxScore: 150, issues: [] },
                        performance: { score: 300, maxScore: 300, issues: [] },
                        security: { score: 200, maxScore: 200, issues: [] },
                        functionality: { score: 200, maxScore: 200, issues: [] },
                        readability: { score: 100, maxScore: 100, issues: [] },
                        advanced: { score: 50, maxScore: 50, issues: [] }
                    },
                    autoFail: false,
                    violations: [],
                    status: 'PASS'
                };

                // Step 1: Check for auto-fail conditions
                if (this.checkAutoFailConditions(query)) {
                    results.autoFail = true;
                    results.totalScore = 0;
                    results.status = 'AUTO_FAIL';
                    results.violations.push({
                        severity: 'critical',
                        title: 'AUTO-FAIL: Critical Pattern Detected',
                        description: 'Query contains patterns that cause automatic failure',
                        category: 'Auto-Fail'
                    });
                    return this.finalizeResults(results, query);
                }

                // Step 2: Validate basic table and structure requirements
                const validationResult = this.validateBasicRequirements(query);
                if (!validationResult.valid) {
                    results.totalScore = Math.min(results.totalScore, 300); // Cap at 300 for invalid queries
                    results.violations.push(...validationResult.violations);
                }

                // Step 3: Apply comprehensive scoring rules
                Object.entries(this.scoringPatterns).forEach(([category, categoryData]) => {
                    const categoryResult = this.evaluateCategory(query, category, categoryData);
                    results.categoryScores[category] = categoryResult;
                    results.violations.push(...categoryResult.issues);
                });

                // Step 4: Calculate final score
                results.totalScore = Object.values(results.categoryScores).reduce((total, cat) => {
                    return total + Math.max(cat.score, 0);
                }, 0);

                // Step 5: Determine final status
                if (results.totalScore >= 700) {
                    results.status = 'PASS';
                } else if (results.totalScore >= 400) {
                    results.status = 'NEEDS_WORK';
                } else {
                    results.status = 'FAIL';
                }

                return this.finalizeResults(results, query);
            }

            checkAutoFailConditions(query) {
                // Check all auto-fail patterns
                for (const [category, patterns] of Object.entries(this.autoFailPatterns)) {
                    for (const pattern of patterns) {
                        if (pattern.test(query)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            validateBasicRequirements(query) {
                const result = { valid: true, violations: [] };
                
                // Check for valid table names
                const tables = this.extractTableNames(query);
                const invalidTables = tables.filter(table => !this.validTables.has(table));
                
                if (invalidTables.length > 0) {
                    result.valid = false;
                    result.violations.push({
                        severity: 'critical',
                        title: 'Invalid Table References',
                        description: `Invalid tables detected: ${invalidTables.join(', ')}`,
                        category: 'Table Validation',
                        points: -200
                    });
                }

                // Check basic query structure
                if (query.trim().length < 15) {
                    result.valid = false;
                    result.violations.push({
                        severity: 'critical',
                        title: 'Insufficient Query Length',
                        description: 'Query is too short to be meaningful',
                        category: 'Structure Validation',
                        points: -150
                    });
                }

                // Check for proper query start
                if (!/^(let\s+\w+|[a-zA-Z]\w*)/.test(query.trim())) {
                    result.valid = false;
                    result.violations.push({
                        severity: 'critical',
                        title: 'Invalid Query Start',
                        description: 'Query must start with table name or let statement',
                        category: 'Structure Validation',
                        points: -100
                    });
                }

                return result;
            }

            evaluateCategory(query, categoryName, categoryData) {
                const result = {
                    score: categoryData.maxPoints,
                    maxScore: categoryData.maxPoints,
                    issues: []
                };

                // Apply each rule in the category
                categoryData.rules.forEach(rule => {
                    const ruleResult = this.evaluateRule(query, rule, categoryName);
                    if (ruleResult.triggered) {
                        result.score += ruleResult.points;
                        result.issues.push(ruleResult.issue);
                    }
                });

                // Ensure score doesn't go below 0 or above max
                result.score = Math.max(0, Math.min(result.score, result.maxScore));
                
                return result;
            }

            evaluateRule(query, rule, category) {
                let triggered = false;
                let matchCount = 0;

                // Check if rule triggers
                if (rule.pattern) {
                    const matches = query.match(rule.pattern);
                    if (matches) {
                        triggered = true;
                        matchCount = matches.length;
                    }
                } else if (rule.test && typeof rule.test === 'function') {
                    const testResult = rule.test(query);
                    if (testResult === true || (typeof testResult === 'string' && testResult)) {
                        triggered = true;
                        matchCount = 1;
                    }
                }

                if (!triggered) {
                    return { triggered: false };
                }

                // Calculate points (multiply by match count for patterns)
                let points = rule.points * matchCount;
                
                // Special handling for dynamic scoring rules
                if (category === 'readability' && rule.title === 'Documentation Quality') {
                    points = this.checkCommentRatio(query);
                }

                // Create issue object
                const issue = {
                    severity: rule.severity || 'minor',
                    title: rule.title,
                    description: rule.description || 'Issue detected in query',
                    category: category,
                    points: points,
                    matches: matchCount,
                    line: this.findQueryLine(query, rule.pattern ? query.match(rule.pattern)?.[0] : '')
                };

                return {
                    triggered: true,
                    points: points,
                    issue: issue
                };
            }

            checkTimeFilterRequirement(query) {
                // Check if query uses time-series tables
                const tables = this.extractTableNames(query);
                const hasTimeSeriesTable = tables.some(table => this.timeSeriesIndicators.has(table));
                
                if (!hasTimeSeriesTable) {
                    return false; // No time filter required for non-time-series tables
                }

                // Check for datetime filter patterns
                const dateTimePatterns = [
                    /TimeGenerated\s*>=\s*ago\(/,
                    /TimeGenerated\s*>\s*datetime\(/,
                    /where.*TimeGenerated.*between/,
                    /timestamp\s*>=\s*ago\(/
                ];

                return !dateTimePatterns.some(pattern => pattern.test(query));
            }

            checkCommentRatio(query) {
                const lines = query.split('\n').filter(line => line.trim());
                const commentLines = lines.filter(line => line.trim().startsWith('//'));
                const ratio = commentLines.length / lines.length;
                
                if (ratio >= 0.2) return 25; // 20%+ commented gets full points
                if (ratio >= 0.1) return 15; // 10%+ commented gets partial points
                if (ratio > 0) return 10;    // Some comments get minimal points
                return 0; // No comments = no points
            }

            finalizeResults(results, query) {
                // Generate comprehensive analysis
                const analysis = {
                    overallScore: results.totalScore,
                    maxScore: results.maxScore,
                    percentage: Math.round((results.totalScore / results.maxScore) * 100),
                    grade: this.calculateGrade(results.totalScore),
                    status: results.status,
                    autoFail: results.autoFail,
                    categories: results.categoryScores,
                    issues: results.violations.sort((a, b) => this.getSeverityWeight(b.severity) - this.getSeverityWeight(a.severity)),
                    metrics: this.calculateAdvancedMetrics(query),
                    aiRecommendations: this.generateComprehensiveRecommendations(query, results),
                    queryExplanation: this.generateQueryExplanation(query),
                    compliance: this.checkEnterpriseCompliance(results)
                };

                return analysis;
            }

            calculateGrade(score) {
                if (score >= 900) return 'Excellent';
                if (score >= 700) return 'Good';
                if (score >= 500) return 'Fair';
                if (score >= 300) return 'Poor';
                return 'Fail';
            }

            calculateAdvancedMetrics(query) {
                const lines = query.split('\n').length;
                const operators = (query.match(/\|/g) || []).length;
                const tables = this.extractTableNames(query);
                const functions = this.extractFunctions(query);
                
                return {
                    linesOfCode: lines,
                    operators: operators,
                    tables: tables.length,
                    functions: functions.length,
                    complexity: Math.min(this.calculateComplexity(query), 10),
                    estimatedCost: this.estimateQueryCost(query),
                    tableNames: tables,
                    functionNames: functions.slice(0, 10) // Limit to first 10
                };
            }

            generateComprehensiveRecommendations(query, results) {
                const recommendations = [];
                
                // Critical issues first
                const criticalIssues = results.violations.filter(i => i.severity === 'critical');
                if (criticalIssues.length > 0) {
                    recommendations.push({
                        priority: 'CRITICAL',
                        title: 'Immediate Action Required',
                        content: `Your query has ${criticalIssues.length} critical issue(s) that prevent proper execution. These must be fixed immediately: ${criticalIssues.map(i => i.title).join(', ')}.`,
                        action: 'Fix critical validation and syntax errors before proceeding',
                        points: criticalIssues.reduce((sum, issue) => sum + Math.abs(issue.points || 0), 0)
                    });
                }

                // Performance recommendations
                const perfIssues = results.violations.filter(i => i.category === 'performance');
                if (perfIssues.length > 0) {
                    const perfPoints = perfIssues.reduce((sum, issue) => sum + Math.abs(issue.points || 0), 0);
                    recommendations.push({
                        priority: 'HIGH',
                        title: 'Performance Optimization Required',
                        content: `Performance issues detected that could significantly impact query execution. Total performance penalty: ${perfPoints} points.`,
                        action: 'Implement time filtering, optimize joins, and reduce data processing overhead',
                        points: perfPoints
                    });
                }

                // Security recommendations
                const securityIssues = results.violations.filter(i => i.category === 'security');
                if (securityIssues.length > 0) {
                    recommendations.push({
                        priority: 'HIGH',
                        title: 'Security Review Required',
                        content: `Security vulnerabilities detected in query. Review data access patterns and sensitive field handling.`,
                        action: 'Remove sensitive data projections and implement proper access controls',
                        points: securityIssues.reduce((sum, issue) => sum + Math.abs(issue.points || 0), 0)
                    });
                }

                // Score-based recommendations
                if (results.totalScore >= 900) {
                    recommendations.push({
                        priority: 'EXCELLENT',
                        title: 'Enterprise Excellence Achieved',
                        content: 'Outstanding query quality! Your KQL demonstrates enterprise-level best practices and optimal performance patterns.',
                        action: 'Consider sharing this query as a template for your team',
                        points: 0
                    });
                } else if (results.totalScore >= 700) {
                    recommendations.push({
                        priority: 'GOOD',
                        title: 'Production Ready with Minor Optimizations',
                        content: 'Good query structure that meets enterprise standards. Address minor issues for optimal performance.',
                        action: 'Implement suggested optimizations for production deployment',
                        points: 1000 - results.totalScore
                    });
                } else if (results.totalScore < 400) {
                    recommendations.push({
                        priority: 'CRITICAL',
                        title: 'Major Redesign Required',
                        content: 'Query requires substantial improvements before any production use. Current implementation has significant issues.',
                        action: 'Complete redesign following enterprise KQL standards',
                        points: 1000 - results.totalScore
                    });
                }

                return recommendations;
            }

            checkEnterpriseCompliance(results) {
                const compliance = {
                    syntax: results.categoryScores.syntax.score >= 120, // 80% of max
                    performance: results.categoryScores.performance.score >= 210, // 70% of max
                    security: results.categoryScores.security.score >= 160, // 80% of max
                    functionality: results.categoryScores.functionality.score >= 140, // 70% of max
                    overall: results.totalScore >= 700
                };

                return compliance;
            }

            evaluateRule(rule, query, allIssues, categoryData, category) {
                let matches = [];
                
                if (rule.test && typeof rule.test === 'function') {
                    if (rule.test(query)) {
                        matches = [true];
                    }
                } else if (rule.pattern) {
                    matches = query.match(rule.pattern) || [];
                }

                if (matches.length > 0) {
                    const issue = {
                        category: category,
                        severity: rule.severity,
                        title: rule.title,
                        description: rule.description || 'Issue detected in query',
                        fix: rule.fix || 'Review and correct the identified issue',
                        impact: rule.impact || 'May affect query performance or reliability',
                        scoreImpact: rule.scoreImpact || 0,
                        line: this.findQueryLine(query, matches[0])
                    };

                    allIssues.push(issue);
                    categoryData.issues.push(issue);
                    categoryData.score = Math.max(categoryData.score + (rule.scoreImpact || 0), 0);
                }
            }

            generateAIRecommendations(query, issues, score) {
                const recommendations = [];
                
                // Critical issues first
                const criticalIssues = issues.filter(i => i.severity === 'critical');
                if (criticalIssues.length > 0) {
                    recommendations.push({
                        priority: 'CRITICAL',
                        title: 'Immediate Action Required',
                        content: `Your query has ${criticalIssues.length} critical issue(s) that will prevent execution. Address these immediately: ${criticalIssues.map(i => i.title).join(', ')}.`,
                        action: 'Fix validation and syntax errors before proceeding'
                    });
                }

                // Performance optimization
                if (!query.match(/TimeGenerated.*ago/gi)) {
                    recommendations.push({
                        priority: 'HIGH',
                        title: 'Performance Optimization',
                        content: 'Adding time boundaries is the single most important optimization for KQL queries. Without time filtering, your query will scan potentially millions of historical records.',
                        action: 'Add: | where TimeGenerated > ago(7d) as your first operation'
                    });
                }

                // Query-specific recommendations
                const tables = this.extractTableNames(query);
                if (tables.includes('SecurityEvent')) {
                    recommendations.push({
                        priority: 'MEDIUM',
                        title: 'SecurityEvent Optimization',
                        content: 'SecurityEvent is a high-volume table. Always filter by EventID early for optimal performance. Common EventIDs: 4624 (successful logon), 4625 (failed logon), 4688 (process creation).',
                        action: 'Add EventID filter after TimeGenerated filter'
                    });
                }

                if (query.match(/\|\s*project\s+\*/gi)) {
                    recommendations.push({
                        priority: 'MEDIUM',
                        title: 'Column Selection Optimization',
                        content: 'Selecting all columns (*) significantly increases data transfer costs and query execution time. Specify only the columns you need for analysis.',
                        action: 'Replace "project *" with specific column names'
                    });
                }

                // Best practices recommendations
                if (!query.includes('//') && query.length > 100) {
                    recommendations.push({
                        priority: 'LOW',
                        title: 'Documentation Best Practice',
                        content: 'Adding comments to complex queries improves maintainability and helps team members understand your analytical methodology.',
                        action: 'Add comments explaining query purpose and methodology'
                    });
                }

                // Score-based recommendations
                if (score >= 9.0) {
                    recommendations.push({
                        priority: 'EXCELLENT',
                        title: 'Query Excellence',
                        content: 'Outstanding query! Your KQL follows enterprise best practices and is optimized for performance. Consider sharing this as a template for your team.',
                        action: 'No action needed - excellent work!'
                    });
                } else if (score >= 7.0) {
                    recommendations.push({
                        priority: 'GOOD',
                        title: 'Good Query Structure',
                        content: 'Your query is well-structured with minor optimization opportunities. Focus on the identified improvements for production readiness.',
                        action: 'Address minor issues for optimal performance'
                    });
                } else if (score < 5.0) {
                    recommendations.push({
                        priority: 'NEEDS_WORK',
                        title: 'Significant Improvements Needed',
                        content: 'This query requires substantial improvements before production use. Focus on critical and major issues first, then optimize for performance.',
                        action: 'Redesign query following identified recommendations'
                    });
                }

                return recommendations;
            }

            generateQueryExplanation(query) {
                const explanations = [];
                
                // Analyze query structure
                const lines = query.split('\n').filter(line => line.trim() && !line.trim().startsWith('//'));
                
                lines.forEach((line, index) => {
                    const trimmed = line.trim();
                    
                    if (index === 0 && !trimmed.startsWith('let')) {
                        const tableName = trimmed.split('|')[0].trim();
                        explanations.push(`📊 Starting analysis from the ${tableName} table`);
                    }
                    
                    if (trimmed.includes('| where TimeGenerated')) {
                        explanations.push(`⏰ Filtering data to recent time period for performance`);
                    }
                    
                    if (trimmed.includes('| where') && !trimmed.includes('TimeGenerated')) {
                        explanations.push(`🔍 Applying business logic filters to narrow data scope`);
                    }
                    
                    if (trimmed.includes('| project')) {
                        explanations.push(`📋 Selecting specific columns for analysis output`);
                    }
                    
                    if (trimmed.includes('| summarize')) {
                        explanations.push(`📈 Performing data aggregation and statistical analysis`);
                    }
                    
                    if (trimmed.includes('| order') || trimmed.includes('| sort')) {
                        explanations.push(`🔢 Sorting results for presentation`);
                    }
                    
                    if (trimmed.includes('| join')) {
                        explanations.push(`🔗 Combining data from multiple sources`);
                    }
                });

                if (explanations.length === 0) {
                    explanations.push(`🤔 Query structure needs improvement for clear analytical flow`);
                }

                return explanations;
            }

            calculateQueryMetrics(query) {
                const lines = query.split('\n').length;
                const operators = (query.match(/\|/g) || []).length;
                const tables = this.extractTableNames(query);
                const functions = this.extractFunctions(query);
                
                return {
                    linesOfCode: lines,
                    operators: operators,
                    tables: tables.length,
                    functions: functions.length,
                    complexity: Math.min(this.calculateComplexity(query), 10),
                    estimatedCost: this.estimateQueryCost(query)
                };
            }

            extractTableNames(query) {
                const tablePattern = /^(\w+)(?:\s*\||\s*$)/gm;
                const matches = [...query.matchAll(tablePattern)];
                return [...new Set(matches.map(m => m[1]).filter(t => 
                    !['let', 'print', 'range'].includes(t.toLowerCase())
                ))];
            }

            extractFunctions(query) {
                const functionPattern = /(\w+)\s*\(/g;
                const matches = [...query.matchAll(functionPattern)];
                return [...new Set(matches.map(m => m[1]))];
            }

            calculateComplexity(query) {
                let complexity = 1;
                const complexPatterns = [
                    { pattern: /join/gi, weight: 2 },
                    { pattern: /union/gi, weight: 1.5 },
                    { pattern: /summarize/gi, weight: 1.5 },
                    { pattern: /mv-expand|mv-apply/gi, weight: 2 },
                    { pattern: /let\s+\w+\s*=/gi, weight: 0.5 }
                ];

                complexPatterns.forEach(({ pattern, weight }) => {
                    const matches = query.match(pattern) || [];
                    complexity += matches.length * weight;
                });

                return complexity;
            }

            estimateQueryCost(query) {
                let cost = 1;
                
                if (!query.match(/TimeGenerated.*ago/gi)) cost *= 15;
                if (query.match(/\|\s*project\s+\*/gi)) cost *= 2;
                if (query.match(/join/gi)) cost *= 3;
                if (query.match(/union/gi)) cost *= 2;
                
                return Math.min(cost, 50);
            }

            checkCompliance(query, issues) {
                const compliance = {
                    syntax: true,
                    performance: true,
                    security: true,
                    documentation: true
                };

                issues.forEach(issue => {
                    if (issue.severity === 'critical' || issue.severity === 'major') {
                        switch (issue.category) {
                            case 'validation':
                            case 'syntax':
                                compliance.syntax = false;
                                break;
                            case 'performance':
                                compliance.performance = false;
                                break;
                            case 'security':
                                compliance.security = false;
                                break;
                        }
                    }
                });

                if (!query.includes('//') && query.length > 150) {
                    compliance.documentation = false;
                }

                return compliance;
            }

            calculateGrade(score) {
                if (score >= 9.0) return 'Excellent';
                if (score >= 7.5) return 'Good';
                if (score >= 6.0) return 'Fair';
                if (score >= 4.0) return 'Poor';
                return 'Fail';
            }

            getSeverityWeight(severity) {
                const weights = { 'critical': 10, 'major': 8, 'minor': 6, 'suggestion': 4, 'good': 2 };
                return weights[severity] || 0;
            }

            findQueryLine(query, searchStr) {
                if (!searchStr || typeof searchStr !== 'string') return 1;
                
                const lines = query.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes(searchStr.substring(0, 20))) {
                        return i + 1;
                    }
                }
                return 1;
            }

            displayResults(analysis) {
                document.getElementById('welcomeState').style.display = 'none';
                document.getElementById('resultsContent').style.display = 'block';
                
                const resultsContent = document.getElementById('resultsContent');
                resultsContent.innerHTML = '';

                // Score display
                this.addScoreDisplay(resultsContent, analysis);

                // AI Recommendations (prominently displayed)
                this.addAIRecommendations(resultsContent, analysis.aiRecommendations);

                // Query Explanation
                this.addQueryExplanation(resultsContent, analysis.queryExplanation);

                // Metrics
                this.addMetricsDisplay(resultsContent, analysis.metrics);

                // Categories with issues
                Object.entries(analysis.categories).forEach(([category, data]) => {
                    if (data.issues.length > 0) {
                        this.addCategorySection(resultsContent, category, data);
                    }
                });

                // Compliance summary
                this.addComplianceSection(resultsContent, analysis.compliance);
            }

            addScoreDisplay(container, analysis) {
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'score-display';
                
                const percentage = Math.round((analysis.overallScore / analysis.maxScore) * 100);
                const statusIcon = analysis.autoFail ? '🚨' : 
                                 analysis.overallScore >= 900 ? '🏆' :
                                 analysis.overallScore >= 700 ? '✅' :
                                 analysis.overallScore >= 400 ? '⚠️' : '❌';
                
                scoreDiv.innerHTML = `
                    <div class="score-number" style="color: ${this.getScoreColor(analysis.overallScore)}">${analysis.overallScore}/1000</div>
                    <div class="score-grade grade-${analysis.grade.toLowerCase()}">${statusIcon} ${analysis.grade}</div>
                    <div class="score-details">
                        ${percentage}% | MXDR365 Enterprise Quality Score
                        ${analysis.autoFail ? '<br><span style="color: var(--mxdr-critical); font-weight: bold;">AUTO-FAIL DETECTED</span>' : ''}
                    </div>
                `;
                
                container.appendChild(scoreDiv);
            }

            addAIRecommendations(container, recommendations) {
                const aiDiv = document.createElement('div');
                aiDiv.className = 'ai-recommendations';
                
                aiDiv.innerHTML = `
                    <div class="ai-title">🤖 MXDR365 AI Analysis & Recommendations</div>
                    <div class="ai-content">
                        ${recommendations.map(rec => `
                            <div style="margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.7); border-radius: 4px; border-left: 3px solid ${this.getPriorityColor(rec.priority)};">
                                <div style="font-weight: 600; color: ${this.getPriorityColor(rec.priority)}; margin-bottom: 6px;">
                                    ${rec.priority}: ${rec.title}
                                </div>
                                <div style="margin-bottom: 8px;">${rec.content}</div>
                                <div style="font-style: italic; color: var(--text-secondary);">💡 ${rec.action}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                container.appendChild(aiDiv);
            }

            addQueryExplanation(container, explanations) {
                const explanationDiv = document.createElement('div');
                explanationDiv.className = 'analysis-section';
                
                explanationDiv.innerHTML = `
                    <div class="analysis-header">
                        <div class="analysis-title">🧠 Query Analysis & Flow Explanation</div>
                    </div>
                    <div class="analysis-content">
                        ${explanations.map(explanation => `
                            <div style="margin-bottom: 8px; padding: 8px 0; border-left: 2px solid var(--mxdr-accent); padding-left: 12px;">
                                ${explanation}
                            </div>
                        `).join('')}
                    </div>
                `;
                
                container.appendChild(explanationDiv);
            }

            addMetricsDisplay(container, metrics) {
                const metricsDiv = document.createElement('div');
                metricsDiv.innerHTML = `
                    <div class="analysis-section">
                        <div class="analysis-header">
                            <div class="analysis-title">📊 Query Complexity Metrics</div>
                        </div>
                        <div class="analysis-content">
                            <div class="metrics-grid">
                                <div class="metric-card">
                                    <div class="metric-value">${metrics.linesOfCode}</div>
                                    <div class="metric-label">Lines</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-value">${metrics.operators}</div>
                                    <div class="metric-label">Operators</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-value">${metrics.tables}</div>
                                    <div class="metric-label">Tables</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-value">${metrics.functions}</div>
                                    <div class="metric-label">Functions</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-value">${metrics.complexity}</div>
                                    <div class="metric-label">Complexity</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-value">${metrics.estimatedCost}x</div>
                                    <div class="metric-label">Cost Factor</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                container.appendChild(metricsDiv);
            }

            addCategorySection(container, category, data) {
                const section = document.createElement('div');
                section.className = 'analysis-section';
                
                const categoryTitles = {
                    syntax: '📝 Syntax & Structure',
                    performance: '⚡ Performance Analysis',
                    security: '🛡️ Security Assessment',
                    functionality: '🔧 Functional Correctness',
                    readability: '📚 Code Quality & Readability',
                    advanced: '🚀 Advanced Features'
                };

                const scoreClass = this.getCategoryScoreClass(data.score, data.maxScore);
                const percentage = Math.round((data.score / data.maxScore) * 100);
                
                section.innerHTML = `
                    <div class="analysis-header">
                        <div class="analysis-title">${categoryTitles[category]}</div>
                        <div class="analysis-score ${scoreClass}">${data.score}/${data.maxScore} (${percentage}%)</div>
                    </div>
                    <div class="analysis-content">
                        ${data.issues.length > 0 ? 
                            data.issues.map(issue => this.createIssueHTML(issue)).join('') :
                            '<div style="color: var(--mxdr-success); text-align: center; padding: 16px;">✅ No issues found in this category</div>'
                        }
                    </div>
                `;
                
                container.appendChild(section);
            }

            addComplianceSection(container, compliance) {
                const section = document.createElement('div');
                section.className = 'analysis-section';
                
                const complianceItems = [
                    { key: 'syntax', label: 'Syntax Standards', icon: '📝' },
                    { key: 'performance', label: 'Performance Standards', icon: '⚡' },
                    { key: 'security', label: 'Security Standards', icon: '🛡️' },
                    { key: 'documentation', label: 'Documentation Standards', icon: '📚' }
                ];
                
                section.innerHTML = `
                    <div class="analysis-header">
                        <div class="analysis-title">🏆 MXDR365 Enterprise Compliance</div>
                    </div>
                    <div class="analysis-content">
                        <div class="metrics-grid">
                            ${complianceItems.map(item => `
                                <div class="metric-card" style="border: 1px solid ${compliance[item.key] ? 'var(--mxdr-success)' : 'var(--mxdr-error)'};">
                                    <div class="metric-value" style="color: ${compliance[item.key] ? 'var(--mxdr-success)' : 'var(--mxdr-error)'}">${item.icon}</div>
                                    <div class="metric-label">${item.label}</div>
                                    <div style="font-size: 0.7rem; color: ${compliance[item.key] ? 'var(--mxdr-success)' : 'var(--mxdr-error)'}; font-weight: 600;">
                                        ${compliance[item.key] ? '✅ PASS' : '❌ FAIL'}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                container.appendChild(section);
            }

            createIssueHTML(issue) {
                const severityEmojis = {
                    'critical': '🚨',
                    'major': '⚠️',
                    'minor': '💡',
                    'suggestion': '💭',
                    'good': '✅'
                };

                const pointsDisplay = issue.points !== undefined ? 
                    `<span style="color: ${issue.points >= 0 ? 'var(--mxdr-success)' : 'var(--mxdr-error)'}; font-weight: bold;">
                        ${issue.points >= 0 ? '+' : ''}${issue.points} pts
                    </span>` : '';

                return `
                    <div class="issue-item issue-${issue.severity}">
                        <div class="issue-header">
                            <div class="issue-title">${severityEmojis[issue.severity]} ${issue.title}</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                ${pointsDisplay}
                                <div class="issue-severity severity-${issue.severity}">${issue.severity}</div>
                            </div>
                        </div>
                        <div class="issue-description">${issue.description}</div>
                        <div class="issue-fix">
                            <strong>Recommendation:</strong> ${issue.fix || issue.action || 'Review and address this issue'}
                            ${issue.line ? `<br><small>📍 Line ${issue.line}</small>` : ''}
                            ${issue.matches > 1 ? `<br><small>🔢 Found ${issue.matches} occurrences</small>` : ''}
                            ${issue.impact ? `<br><small>💡 Impact: ${issue.impact}</small>` : ''}
                        </div>
                    </div>
                `;
            }

            getScoreColor(score) {
                if (score >= 9.0) return 'var(--mxdr-success)';
                if (score >= 7.5) return 'var(--mxdr-primary)';
                if (score >= 6.0) return 'var(--mxdr-warning)';
                return 'var(--mxdr-error)';
            }

            getCategoryScoreClass(score) {
                if (score >= 8.5) return 'score-excellent';
                if (score >= 7.0) return 'score-good';
                if (score >= 5.5) return 'score-fair';
                return 'score-poor';
            }

            getPriorityColor(priority) {
                const colors = {
                    'CRITICAL': 'var(--mxdr-critical)',
                    'HIGH': 'var(--mxdr-error)',
                    'MEDIUM': 'var(--mxdr-warning)',
                    'LOW': 'var(--mxdr-primary)',
                    'EXCELLENT': 'var(--mxdr-success)',
                    'GOOD': 'var(--mxdr-primary)',
                    'NEEDS_WORK': 'var(--mxdr-error)'
                };
                return colors[priority] || 'var(--mxdr-primary)';
            }

            toggleChat() {
                const chat = document.getElementById('aiChat');
                const toggle = document.getElementById('chatToggle');
                
                if (chat.style.display === 'flex') {
                    chat.style.display = 'none';
                    toggle.style.display = 'block';
                } else {
                    chat.style.display = 'flex';
                    toggle.style.display = 'none';
                }
            }

            async sendChatMessage(message) {
                const chatBody = document.getElementById('chatBody');
                
                // Add user message
                const userMsg = document.createElement('div');
                userMsg.className = 'chat-message chat-user';
                userMsg.textContent = message;
                chatBody.appendChild(userMsg);
                
                chatBody.scrollTop = chatBody.scrollHeight;

                // Show thinking
                const thinkingMsg = document.createElement('div');
                thinkingMsg.className = 'chat-message chat-ai';
                thinkingMsg.innerHTML = '<em>🤔 MXDR365 AI analyzing...</em>';
                thinkingMsg.id = 'thinking-msg';
                chatBody.appendChild(thinkingMsg);
                chatBody.scrollTop = chatBody.scrollHeight;

                // Wait and generate response
                await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 1200));
                
                // Remove thinking message
                const thinking = document.getElementById('thinking-msg');
                if (thinking) thinking.remove();

                // Generate intelligent response
                const response = await this.generateIntelligentAIResponse(message);
                
                const aiMsg = document.createElement('div');
                aiMsg.className = 'chat-message chat-ai';
                aiMsg.innerHTML = response;
                chatBody.appendChild(aiMsg);
                chatBody.scrollTop = chatBody.scrollHeight;
            }

            async generateIntelligentAIResponse(message) {
                const currentQuery = document.getElementById('queryEditor').value.trim();
                const messageLower = message.toLowerCase();
                
                // Context-aware AI responses based on query analysis
                if (messageLower.includes('optimize') || messageLower.includes('performance')) {
                    if (currentQuery) {
                        const hasTimeFilter = currentQuery.match(/TimeGenerated.*ago\(/gi);
                        const hasWildcard = currentQuery.match(/\|\s*project\s+\*/gi);
                        const tables = this.extractTableNames(currentQuery);
                        
                        let response = `<strong>🚀 MXDR365 Performance Analysis:</strong><br><br>`;
                        
                        if (!hasTimeFilter) {
                            response += `🔴 <strong>CRITICAL:</strong> Your query lacks time filtering! This will scan the entire table history.<br>`;
                            response += `💡 <strong>Fix:</strong> Add "| where TimeGenerated > ago(7d)" as your first operation.<br><br>`;
                        }
                        
                        if (hasWildcard) {
                            response += `🟡 <strong>MAJOR:</strong> Using "project *" increases data transfer costs significantly.<br>`;
                            response += `💡 <strong>Fix:</strong> Specify only needed columns like "| project TimeGenerated, Computer, Account"<br><br>`;
                        }
                        
                        if (tables.includes('SecurityEvent')) {
                            response += `🛡️ <strong>SecurityEvent Tip:</strong> This is a high-volume table. Always filter by EventID early:<br>`;
                            response += `• EventID 4624 = Successful logon<br>`;
                            response += `• EventID 4625 = Failed logon<br>`;
                            response += `• EventID 4688 = Process creation<br><br>`;
                        }
                        
                        response += `⚡ <strong>Quick Wins:</strong><br>`;
                        response += `1. Time filter first (most important)<br>`;
                        response += `2. Use equality (==) before contains operations<br>`;
                        response += `3. Filter before extending or computing<br>`;
                        response += `4. Use "top N" instead of "order by + take"`;
                        
                        return response;
                    } else {
                        return `<strong>🚀 KQL Performance Best Practices:</strong><br><br>
                        <strong>Critical Rules:</strong><br>
                        1. <strong>Time filtering first</strong> - Always use "| where TimeGenerated > ago(Xd)"<br>
                        2. <strong>Early filtering</strong> - Filter before any computations<br>
                        3. <strong>Specific projections</strong> - Avoid "project *"<br>
                        4. <strong>Index-friendly operations</strong> - Use equality before regex<br><br>
                        <strong>Common Patterns:</strong><br>
                        • Use "top 100 by Column" instead of "order by Column | take 100"<br>
                        • Filter high-cardinality tables early (SecurityEvent, SigninLogs)<br>
                        • Use "has" instead of "contains" when possible<br><br>
                        💡 Paste your query for specific optimization advice!`;
                    }
                }
                
                if (messageLower.includes('security') || messageLower.includes('event')) {
                    return `<strong>🛡️ MXDR365 Security Analytics Guide:</strong><br><br>
                    <strong>Key Security Tables:</strong><br>
                    • <strong>SecurityEvent</strong> - Windows security logs<br>
                    • <strong>SigninLogs</strong> - Azure AD authentication<br>
                    • <strong>DeviceEvents</strong> - Endpoint security events<br>
                    • <strong>AlertInfo</strong> - Security alerts and incidents<br><br>
                    <strong>Critical EventIDs:</strong><br>
                    • <strong>4624</strong> - Successful logon (monitor for privilege escalation)<br>
                    • <strong>4625</strong> - Failed logon (detect brute force attacks)<br>
                    • <strong>4688</strong> - Process creation (malware execution)<br>
                    • <strong>4672</strong> - Special privileges assigned<br><br>
                    <strong>Best Practices:</strong><br>
                    • Always include Account and Computer fields for incident response<br>
                    • Use LogonType to understand authentication context<br>
                    • Correlate with DeviceEvents for comprehensive analysis<br>
                    • Filter by WorkstationName for lateral movement detection`;
                }
                
                if (messageLower.includes('syntax') || messageLower.includes('error')) {
                    if (currentQuery) {
                        const errors = [];
                        if (currentQuery.match(/\|\s*\|/)) errors.push('Double pipes detected');
                        if (currentQuery.match(/\b(WHERE|SUMMARIZE|PROJECT)\b/)) errors.push('Uppercase operators should be lowercase');
                        if (currentQuery.match(/;$/m)) errors.push('Unnecessary semicolons');
                        
                        let response = `<strong>📝 MXDR365 Syntax Analysis:</strong><br><br>`;
                        
                        if (errors.length > 0) {
                            response += `🔴 <strong>Issues Found:</strong><br>`;
                            errors.forEach(error => response += `• ${error}<br>`);
                            response += `<br>`;
                        }
                        
                        response += `<strong>KQL Syntax Rules:</strong><br>`;
                        response += `• Operators: where, summarize, project (lowercase)<br>`;
                        response += `• Pipes: Single | between operations<br>`;
                        response += `• Strings: Use double quotes "text"<br>`;
                        response += `• Comments: // for single line, /* */ for multi-line<br>`;
                        response += `• No semicolons needed at end of statements`;
                        
                        return response;
                    } else {
                        return `<strong>📝 KQL Syntax Guidelines:</strong><br><br>
                        <strong>Basic Structure:</strong><br>
                        TableName<br>
                        | where condition<br>
                        | project columns<br>
                        | summarize aggregation<br><br>
                        <strong>Common Mistakes:</strong><br>
                        ❌ WHERE (use: where)<br>
                        ❌ || (use: |)<br>
                        ❌ ending with ; (not needed)<br>
                        ❌ 'single quotes' (use: "double quotes")<br><br>
                        <strong>Best Practices:</strong><br>
                        ✅ Start with table name<br>
                        ✅ Use lowercase operators<br>
                        ✅ Add comments with //<br>
                        ✅ Proper spacing around pipes`;
                    }
                }
                
                if (messageLower.includes('table') || messageLower.includes('join')) {
                    return `<strong>🔗 MXDR365 Table Operations:</strong><br><br>
                    <strong>Valid MXDR365 Tables:</strong><br>
                    • SecurityEvent, SigninLogs, DeviceEvents<br>
                    • AlertInfo, ThreatIntelligenceIndicator<br>
                    • CommonSecurityLog, AzureActivity<br>
                    • OfficeActivity, PowerBIAudit<br><br>
                    <strong>Join Best Practices:</strong><br>
                    • Always specify join kind: inner, leftouter, rightouter<br>
                    • Filter both tables before joining<br>
                    • Use indexed columns as join keys<br>
                    • Example: SecurityEvent | join kind=inner (DeviceEvents) on Computer<br><br>
                    <strong>Performance Tips:</strong><br>
                    • Join smaller table to larger table<br>
                    • Use TimeGenerated filters on both sides<br>
                    • Project only needed columns before join`;
                }
                
                if (messageLower.includes('help') || messageLower.includes('what can you')) {
                    return `<strong>🤖 MXDR365 AI Assistant Capabilities:</strong><br><br>
                    <strong>Query Analysis:</strong><br>
                    • Comprehensive syntax validation<br>
                    • Performance optimization recommendations<br>
                    • Security best practices assessment<br>
                    • Enterprise compliance scoring<br><br>
                    <strong>Expert Guidance:</strong><br>
                    • KQL syntax and structure help<br>
                    • Table-specific optimization advice<br>
                    • Security analytics methodologies<br>
                    • Troubleshooting and debugging<br><br>
                    <strong>Specialized Areas:</strong><br>
                    • Threat hunting query design<br>
                    • Detection rule optimization<br>
                    • Incident investigation techniques<br>
                    • Cost optimization strategies<br><br>
                    💡 Ask me about any KQL topic or paste your query for analysis!`;
                }
                
                if (messageLower.includes('threat') || messageLower.includes('hunt')) {
                    return `<strong>🎯 MXDR365 Threat Hunting Excellence:</strong><br><br>
                    <strong>Hunting Methodology:</strong><br>
                    1. <strong>Hypothesis</strong> - Define what you're hunting for<br>
                    2. <strong>Data Sources</strong> - Select relevant tables<br>
                    3. <strong>Analytics</strong> - Build detection logic<br>
                    4. <strong>Validation</strong> - Test with known data<br><br>
                    <strong>Common Hunting Patterns:</strong><br>
                    • Lateral movement: Join SecurityEvent + DeviceEvents<br>
                    • Privilege escalation: EventID 4672 + 4624 correlation<br>
                    • Data exfiltration: Large file transfers + external IPs<br>
                    • Living off the land: PowerShell + cmd execution patterns<br><br>
                    <strong>Pro Tips:</strong><br>
                    • Use statistical analysis (percentile, stdev) for baselines<br>
                    • Correlate multiple data sources for higher fidelity<br>
                    • Document hunting hypotheses in query comments`;
                }
                
                if (messageLower.includes('explain') && currentQuery) {
                    const explanation = this.generateQueryExplanation(currentQuery);
                    let response = `<strong>🧠 MXDR365 Query Explanation:</strong><br><br>`;
                    
                    response += `<strong>Your Query Analysis:</strong><br>`;
                    explanation.forEach(exp => {
                        response += `${exp}<br>`;
                    });
                    
                    const tables = this.extractTableNames(currentQuery);
                    if (tables.length > 0) {
                        response += `<br><strong>Tables Used:</strong><br>`;
                        tables.forEach(table => {
                            response += `• <strong>${table}</strong> - ${this.getTableDescription(table)}<br>`;
                        });
                    }
                    
                    return response;
                }
                
                // General contextual response
                if (currentQuery) {
                    const score = this.quickScoreQuery(currentQuery);
                    return `<strong>🔍 Quick Query Assessment:</strong><br><br>
                    Estimated Score: <strong>${score}/1000</strong><br><br>
                    I can help you with:<br>
                    • Detailed performance optimization<br>
                    • Syntax validation and fixes<br>
                    • Security best practices<br>
                    • Query explanation and logic review<br><br>
                    💡 Ask me specific questions about your query or KQL concepts!`;
                } else {
                    return `<strong>🤖 MXDR365 AI Ready!</strong><br><br>
                    I'm here to help with enterprise KQL analysis. You can ask me about:<br><br>
                    • Query optimization and performance<br>
                    • KQL syntax and troubleshooting<br>
                    • Security analytics best practices<br>
                    • Table operations and joins<br>
                    • Threat hunting methodologies<br><br>
                    📝 Paste your KQL query for comprehensive analysis, or ask any KQL question!`;
                }
            }

            getTableDescription(table) {
                const descriptions = {
                    'SecurityEvent': 'Windows security events and authentication logs',
                    'SigninLogs': 'Azure AD user authentication and sign-in activities',
                    'DeviceEvents': 'Endpoint security events and device activities',
                    'AlertInfo': 'Security alerts and incident information',
                    'DeviceProcessEvents': 'Process creation and execution events',
                    'DeviceNetworkEvents': 'Network connection and traffic events',
                    'CommonSecurityLog': 'Common Event Format (CEF) security logs',
                    'AzureActivity': 'Azure resource management and activity logs'
                };
                return descriptions[table] || 'Security and operational data table';
            }

            quickScoreQuery(query) {
                let score = 10;
                
                if (!query.match(/TimeGenerated.*ago/gi)) score -= 3;
                if (query.match(/\|\s*project\s+\*/gi)) score -= 1.5;
                if (query.match(/\|\s*\|/g)) score -= 2;
                if (!this.extractTableNames(query).every(t => this.validTables.has(t))) score -= 3;
                if (!query.includes('//') && query.length > 100) score -= 0.5;
                
                return Math.max(Math.round(score * 10) / 10, 0);
            }

            showAlert(message) {
                alert(message);
            }
        }

        // Global functions for chat interface
        function toggleChat() {
            analyzer.toggleChat();
        }

        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (message) {
                analyzer.sendChatMessage(message);
                input.value = '';
            }
        }

        function handleChatEnter(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Initialize the MXDR365 analyzer
        let analyzer;
        document.addEventListener('DOMContentLoaded', () => {
            analyzer = new MXDR365KQLAnalyzer();
        });
    </script>
</body>
</html>
                
